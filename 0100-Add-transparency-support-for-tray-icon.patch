From 49977bfb42007f56330a1ff0e9705d06709af0c2 Mon Sep 17 00:00:00 2001
From: Weng Xuetian <wengxt@gmail.com>
Date: Mon, 8 Feb 2016 18:55:21 -0800
Subject: [PATCH 100/105] Add transparency support for tray icon

The selection manager of tray may hold a property to indicate the tray
icon window visual. Try to use the visual with alpha channel when
composite is enabled.

REVIEW: 127009
---
 xembed-sni-proxy/fdoselectionmanager.cpp | 44 ++++++++++++++++++++++++++++++++
 xembed-sni-proxy/fdoselectionmanager.h   |  1 +
 xembed-sni-proxy/sniproxy.cpp            |  2 +-
 xembed-sni-proxy/xcbutils.h              |  5 ++--
 4 files changed, 49 insertions(+), 3 deletions(-)

diff --git a/xembed-sni-proxy/fdoselectionmanager.cpp b/xembed-sni-proxy/fdoselectionmanager.cpp
index f236e9c..ab91044 100644
--- a/xembed-sni-proxy/fdoselectionmanager.cpp
+++ b/xembed-sni-proxy/fdoselectionmanager.cpp
@@ -171,6 +171,9 @@ void FdoSelectionManager::undock(xcb_window_t winId)
 void FdoSelectionManager::onClaimedOwnership()
 {
     qCDebug(SNIPROXY) << "Manager selection claimed";
+
+    connect(KWindowSystem::self(), &KWindowSystem::compositingChanged, this, &FdoSelectionManager::compositingChanged);
+    compositingChanged();
 }
 
 void FdoSelectionManager::onFailedToClaimOwnership()
@@ -182,5 +185,46 @@ void FdoSelectionManager::onFailedToClaimOwnership()
 void FdoSelectionManager::onLostOwnership()
 {
     qCWarning(SNIPROXY) << "lost ownership of Systray Manager";
+    disconnect(KWindowSystem::self(), &KWindowSystem::compositingChanged, this, &FdoSelectionManager::compositingChanged);
     qApp->exit(-1);
 }
+
+void FdoSelectionManager::compositingChanged()
+{
+    xcb_connection_t *c = QX11Info::connection();
+    auto screen = xcb_setup_roots_iterator (xcb_get_setup (c)).data;
+    auto trayVisual = screen->root_visual;
+    if (KWindowSystem::compositingActive()) {
+        xcb_depth_iterator_t depth_iterator = xcb_screen_allowed_depths_iterator(screen);
+        xcb_depth_t *depth = nullptr;
+
+        while (depth_iterator.rem) {
+            if (depth_iterator.data->depth == 32) {
+                depth = depth_iterator.data;
+                break;
+            }
+            xcb_depth_next(&depth_iterator);
+        }
+
+        if (depth) {
+            xcb_visualtype_iterator_t visualtype_iterator = xcb_depth_visuals_iterator(depth);
+            while (visualtype_iterator.rem) {
+                xcb_visualtype_t *visualtype = visualtype_iterator.data;
+                if (visualtype->_class == XCB_VISUAL_CLASS_TRUE_COLOR) {
+                    trayVisual = visualtype->visual_id;
+                    break;
+                }
+                xcb_visualtype_next(&visualtype_iterator);
+            }
+        }
+    }
+
+    xcb_change_property(c,
+                        XCB_PROP_MODE_REPLACE,
+                        m_selectionOwner->ownerWindow(),
+                        Xcb::atoms->visualAtom,
+                        XCB_ATOM_VISUALID,
+                        32,
+                        1,
+                        &trayVisual);
+}
diff --git a/xembed-sni-proxy/fdoselectionmanager.h b/xembed-sni-proxy/fdoselectionmanager.h
index 911df6c..650d52f 100644
--- a/xembed-sni-proxy/fdoselectionmanager.h
+++ b/xembed-sni-proxy/fdoselectionmanager.h
@@ -51,6 +51,7 @@ private:
     void addDamageWatch(xcb_window_t client);
     void dock(xcb_window_t embed_win);
     void undock(xcb_window_t client);
+    void compositingChanged();
 
     uint8_t m_damageEventBase;
 
diff --git a/xembed-sni-proxy/sniproxy.cpp b/xembed-sni-proxy/sniproxy.cpp
index b7bb799..662c521 100644
--- a/xembed-sni-proxy/sniproxy.cpp
+++ b/xembed-sni-proxy/sniproxy.cpp
@@ -262,7 +262,7 @@ QImage SNIProxy::getImageNonComposite() const
         return QImage();
     }
 
-    xcb_image_t *image = xcb_image_get(c, m_windowId, 0, 0, geom->width, geom->height, 0xFFFFFF, XCB_IMAGE_FORMAT_Z_PIXMAP);
+    xcb_image_t *image = xcb_image_get(c, m_windowId, 0, 0, geom->width, geom->height, 0xFFFFFFFF, XCB_IMAGE_FORMAT_Z_PIXMAP);
 
     // Don't hook up cleanup yet, we may use a different QImage after all
     QImage naiveConversion = QImage(image->data, image->width, image->height, QImage::Format_ARGB32);
diff --git a/xembed-sni-proxy/xcbutils.h b/xembed-sni-proxy/xcbutils.h
index 5e2b6dc..fb3291a 100644
--- a/xembed-sni-proxy/xcbutils.h
+++ b/xembed-sni-proxy/xcbutils.h
@@ -109,14 +109,15 @@ public:
         xembedAtom("_XEMBED"),
         selectionAtom(xcb_atom_name_by_screen("_NET_SYSTEM_TRAY", QX11Info::appScreen())),
         opcodeAtom("_NET_SYSTEM_TRAY_OPCODE"),
-        messageData("_NET_SYSTEM_TRAY_MESSAGE_DATA")
+        messageData("_NET_SYSTEM_TRAY_MESSAGE_DATA"),
+        visualAtom("_NET_SYSTEM_TRAY_VISUAL")
     {}
 
     Atom xembedAtom;
     Atom selectionAtom;
     Atom opcodeAtom;
     Atom messageData;
-
+    Atom visualAtom;
 };
 
 extern Atoms* atoms;
-- 
2.5.0

